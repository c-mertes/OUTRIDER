%\VignetteIndexEntry{OUTRIDER: OUTlier in RNA-seq fInDER}
%\VignettePackage{OUTRIDER}
%\VignetteEngine{knitr::knitr}
%\VignetteEncoding{UTF-8}

\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{verbatim}
\newcommand{\outrider}{\Biocpkg{OUTRIDER}}
\newcommand{\rna}{RNA-seq}
\newcommand{\deseq}{\Biocpkg{DESeq2}}
\newcommand{\ods}{\Rclass{OutriderDataSet}}

\title{OUTRIDER - OUTlier RNA-Seq fInDER}

<<style, eval=TRUE, echo=FALSE, results="asis">>=
BiocStyle::latex()
@

<<knitr, echo=FALSE, cache=FALSE, results="hide">>=
library("knitr")
opts_chunk$set(
    tidy=FALSE,
    dev="png",
    fig.width=7,
    fig.height=7,
    dpi = 300,
    message=FALSE,
    warning=FALSE,
    cache=TRUE
)
@

\author{
    Felix Brechtmann$^{1}$, Christian Mertes$^{1}$, Agne Matuseviciute$^{1}$, 
        Vicente Yepez$^{1}$, Julien Gagneur$^{1}$ \\
    \small{$^{1}$ Technische Universit\"at M\"unchen, Department of 
        Informatics, Garching, Germany}
}

\begin{document}
\SweaveOpts{concordance=TRUE}

\maketitle

\begin{abstract}

In the field of diagnostics of rare diseases, \rna{} is emerging as an 
important and complementary tool for whole exome and whole genome sequencing. 
\outrider{} is a framework which detects aberrant gene expression within a 
group of samples. It uses the negative binomial distribution which is fitted 
for each gene over all samples. We additionally provide an autoencoder, 
which automatically controls for co-variation before fitting. After fitting,
each sample can be tested for aberrantly expressed genes. Furthermore,
\outrider{} provides methods to easily filter unexpressed genes and 
visualize the results.

\vspace{3em}

\begin{center}
\begin{tabular}{ | l | }
\hline
If you use \outrider{} in published research, please cite:  \\
\\
Brechtmann F*, Matuseviciute A*, Mertes C*, Yepez V, Avsec Z, Herzog M, \\
Bader D M, Prokisch H, Gagneur J; \textbf{OUTRIDER: A statistical method} \\
\textbf{for detecting aberrantly expressed genes in RNA sequencing data}; \\
\emph{bioRxiv}; 2018 \\
\hline
\end{tabular}
\end{center}

\end{abstract}

\newpage

\tableofcontents

\newpage


<<hiden_config, echo=FALSE, cache=FALSE>>=
suppressPackageStartupMessages({
    library(OUTRIDER)
    library(beeswarm)
})
if(multicoreWorkers() >= 4){
    register(MulticoreParam(min(6, multicoreWorkers())))
} else {
    register(SerialParam())
}
@

\section{Introduction}
\outrider{} (OUTlier in Rna-seq fInDER) is a tool to find aberrantly expressed
genes in RNA-seq samples. It does so by fitting a negative binomial model 
to RNA-seq read counts, correcting for variations in sequencing depth and 
apparent co-variations across samples. Read counts significantly deviating 
from the distribution are detected as outliers.

Differential gene expression analysis from RNA-seq data is well-established.
The packages \deseq{} or \Biocpkg{edgeR} provide effective 
workflows and preprocessing steps to perform differential gene expression 
analysis. However, these methods aim at detecting significant differences
between groups of samples. In contrast, \outrider{} aims at detecting
outliers within a given population. A scheme of this difference is given 
in figure \ref{fig:deVsOutlier}.

<<deVsOutlier, echo=FALSE, fig.height=5, fig.cap="Scheme of workflow differences. Differences between differential gene expression analysis and outlier detection.">>=
par.old <- par(no.readonly=TRUE)
par(mfrow=c(1,2), cex=1.2)
ylim <- c(80, 310)
a <- rnorm(10, 250, 10)
b <- rnorm(10, 120, 10)
c <- rnorm(100, 250, 20)
c[1] <- 105
beeswarm(list(A=a, B=b), main="Differential expression\nanalysis",
     xlab="Condition", ylab="Expression", ylim=ylim, pch=20, 
     col=c("darkblue", "firebrick"))
beeswarm(c, main="Outlier detection", ylim=ylim, pch=20, 
    xlab="Population", ylab="Expression", col="firebrick")

par(par.old)
@

\section{Prerequisites}
To get started on the preprocessing step, we recommend to read the 
introductions of the aforementioned tools or the RNA-seq workflow from
Bioconductor. In brief, one usually starts with the raw FASTQ files from
the RNA sequencing run. Those are then aligned to a given reference genome. As of
now (May 2018), we recommend the STAR aligner. After obtaining the aligned BAM
files, one can map the reads to exons or genes of a GTF annotation file using HT-seq.
The resulting count table can then be loaded into the \outrider{} package
as we will describe below.

\section{A quick tour}

Here we assume that we already have a count table and no additional 
preprocessing needs to be done. Then we can start and obtain results with 
3 commands. First, create an \ods{} from a count table, then run the full 
pipeline using the command \Rfunction{OUTRIDER}. In a third step, a results
table can be generated from the \ods{} with the \Rfunction{results} function.
Furthermore, analysis plots, which are described in section \ref{sec:Results},
can be created from the \ods{} object directly.

<<quick_guide, fig.height=5>>=
library(OUTRIDER)

# get data
ctsFile <- system.file('extdata', 'KremerNBaderSmall.tsv', 
        package='OUTRIDER')
ctsTable <- read.table(ctsFile, check.names=FALSE)
ods <- OutriderDataSet(countData=ctsTable)

# filter out non expressed genes
ods <- filterExpression(ods, onlyZeros=TRUE, filterGenes=TRUE)

# run full OUTRIDER pipeline (control, fit model, calculate P-values)
ods <- OUTRIDER(ods)

# results (only significant)
res <- results(ods)
head(res)

# example of a QQplot for the first outlier
geneID <- res[1, geneID]
plotQQ(ods, geneID)
@

\section{An \outrider{} analysis in detail}

For this Tutorial we will use the full rare disease data set from Kremer 
et al. For testing, this package contains also a subset of it.

<<GetDataSet>>=
URL <- paste0("https://media.nature.com/original/nature-assets/", 
        "ncomms/2017/170612/ncomms15824/extref/ncomms15824-s1.txt")
ctsTable <- read.table(URL, sep="\t")

# create OutriderDataSet object
ods <- OutriderDataSet(countData=ctsTable)
@

\subsection{Preprocessing}

It is recommended to apply some data preprocessing before fitting. Our
model requires that for every gene there is at least one sample with counts and 
for large data sets, that there is at least one count in 100 samples. Therefore,
all genes that are not expressed must be discarded.

We provide the function \Rfunction{filterExpression} to remove genes which have 
low FPKM expression values. The needed annotation to estimate FPKM values 
from the counts should be the same as for the counting. Here, we normalize 
by the total exon length of a gene.

By default the cutoff is set to an FPKM value of one and only the filtered
\ods{} object is returned. If required, the FPKM values can be stored in the
\ods{} object and the full object can be returned to visualize the 
distribution of reads before and after filtering. 

<<Preprocessing, fig.height=5>>=
# get annotation
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(org.Hs.eg.db)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
map <- select(org.Hs.eg.db, keys=keys(txdb, keytype = "GENEID"), 
        keytype="ENTREZID", columns=c("SYMBOL"))
@

The \Robject{TxDb.Hsapiens.UCSC.hg19.knownGene} contains only well annotated 
genes. This annotation will miss a lot of genes. To include all predicted 
annotations as well as non-coding RNAs please download the txdb object from 
our homepage\footnote{\url{https://i12g-gagneurweb.in.tum.de/public/paper/mitoMultiOmics/ucsc.knownGenes.db}}
or create it yourself from the UCSC website\footnote{\url{https://genome.ucsc.edu/cgi-bin/hgTables}}$^,$\footnote{\url{http://genomewiki.ucsc.edu/index.php/Genes_in_gtf_or_gff_format}}.

<<create txdb, eval=FALSE>>=
library(RMySQL)
library(AnnotationDbi)
txdbUrl <- paste0("https://i12g-gagneurweb.in.tum.de/public/",
        "paper/mitoMultiOmics/ucsc.knownGenes.db")
download.file(txdbUrl, "ucsc.knownGenes.db")
txdb <- loadDb("ucsc.knownGenes.db")
con <- dbConnect(MySQL(), host='genome-mysql.cse.ucsc.edu', 
        dbname="hg19", user='genome')
map <- dbGetQuery(con, 'select kgId AS TXNAME, geneSymbol from kgXref')

@

<<filtering, fig.height=5>>=
# calculating FPKM values and only labeling not expressed genes
ods <- filterExpression(ods, txdb, mapping=map, 
        filterGenes=FALSE, savefpkm=TRUE)

# display the pre distribution of counts.
plotFPKM(ods)

# do the actual subsetting based on the filtering labels
ods <- filterExpression(ods, txdb, mapping=map,
        filterGenes=TRUE, savefpkm=TRUE)
@

\subsection{Controlling for Confounders}

A next step in any analysis workflow is to visualize the correlations
between samples. Here, we observe that samples are correlated. These 
correlations are often due to confounders, technical like the sequencing 
batch, or biological ones like sex. These confounders can harm the 
detection of aberrant features. Therefore, we provide options to control 
for them.

<<plotting_between_sample_correlations>>=

# Heatmap of the sample correlation
# it annotates also the clusters resulting from the dendrogram
ods <- plotCountCorHeatmap(ods, normalized=FALSE, nCluster=4)

@

We have different ways to control for confounders present in the data.
The first and standard way is to calculate the \Rfunction{sizeFactors} 
as done in \deseq{}. 

Additionally, the \Rfunction{autoCorrect} function calls an 
autoencoder, which automatically controls for confounders present in the data.
After controlling for them, the heatmap should be plotted again.
If it worked, no batches should be present and the correlations between 
samples should be close to zero.

<<controlling_for_confounders>>=

# automatically control for confounders 
ods <- estimateSizeFactors(ods)
ods <- autoCorrect(ods, q=13)

# Heatmap of the sample correlation after controlling
ods <- plotCountCorHeatmap(ods, normalized=TRUE)

@

Alternatively, a \Rfunction{normalizationFactor} matrix can be provided. 
It must be computed beforehand using any method. Its purpose is to normalize
for technical effects or control for additional expression patterns.

\subsection{Fitting}

After all the preprocessing part, we can finally start fitting and testing. 
We provide a single wrapper function \Rfunction{OUTRIDER} to run the full 
pipeline, but it can also be run step by step. By default the 
\Rfunction{OUTRIDER} function runs all analysis functions and controls the 
counts using \Rfunction{autoCorrect}. It does not include any preprocessing
functions. Discarding genes or samples should be done manually 
before running the \Rfunction{OUTRIDER} function or starting the analysis
pipeline.

To fit the dispersion and the mean, the \Rfunction{fit} function is applied
to the \ods{}.

<<fitting>>=
# fit NB to each feature
ods <- fit(ods)

# plot dispersion versus mean counts 
plotDispEsts(ods)
@

\subsection{P-value computation}

After determining the fit parameters, two-sided P-values are computed using 
the following equation:

\begin{equation}
    p_{ij} = 2 \cdot min \left\{\frac{1}{2}, \sum_{0}^{k_{ij}} 
        NB(\mu_{ij} ,\theta_i), 1 - \sum_{0}^{k_{ij-1}} 
        NB(\mu_{ij} ,\theta_i) \right\}
\end{equation}

where the $\frac{1}{2}$ term handles the case of both terms exceeding 0.5, 
which can happen due to the discrete nature of the negative binomial 
distribution. Here $\mu_{ij}$ are computed as the product of the fitted 
correction values from the autoencoder and the fitted mean adjustements. 
If required a one-sided test can be performed using the 
alternative argument and specifying 'less' or 'greater' depending on 
the research question. Multiple testing correction is done across all genes
in a per-sample fashion using Benjamini-Yekutieli's false discovery rate method
(Benjamini and Yekutieli, 2001). Alternatively, all other by \Rfunction{p.adjust}
supported methods can be used via the \Robject{method} parameter.

<<pValue_computation>>=
# compute pValues (nominal and adjusted)
ods <- computePvalues(ods, alternative="two.sided", method="BY")
@

\subsection{Z-score calculation}
The Z-scores on the log2 transformed counts can be used for visualization,
filtering, and ranking of samples. By running the \Rfunction{computeZscores}
function, the Z-scores are computed and stored in the \ods{} object.
The Z-scores are calculated using:

\begin{equation}
    z_{ij} = \frac{l_{ij} - \mu_j^l}{\sigma_j^l}
\end{equation}
\begin{equation*}
    l_{ij} = \log{(\frac{k_{ij} + 1}{c_{ij}})}
\end{equation*}

Where $\mu_j^l$ is the mean and $\sigma_j^l$ the 
standard deviation of $l_{ij}$ for gene $j$. Here $l_{ij}$ are the log2 
transformed counts after correction for confounders.

<<zScore_computation>>=
# compute and store the Z-scores
ods <- computeZscores(ods)
@

\section{Results}
\label{sec:Results}
The \outrider{} package offers multiple ways to display the results. It 
creates a results table containing all the values computed during the analysis.
Furthermore, it offers various plot functions, which guide the user 
through the analysis. 

\subsection{Results table}

The \Rfunction{results} function gathers all the previously computed values
and combines them into one table.

<<results>>=
# get results (only significant, padj < 0.05)
res <- results(ods, zScore=0)
head(res)
dim(res)

# setting a different significant level or filtering for Z-scores
res <- results(ods, padj=0.1, zScore=2)
head(res)
dim(res)
@


\subsection{Number of aberrant genes per sample}

One quantity of interest is the number of aberrantly expressed genes 
per sample. This can be displayed using the \Rfunction{plotAberrantPerSample}
plotting function. Alternatively, the \Rfunction{aberrant} function can be 
used to compute the number of aberrant counts. Those can be computed by sample,
gene or in the whole data set. These numbers depend on the 
cutoffs, which can be specified in both functions.

<<aberrantperSample, fig.height=5>>=
# number of aberrant genes per sample
tail(sort(aberrant(ods, by="sample")))
tail(sort(aberrant(ods, by="gene", zScore=1)))

# plotting the aberrant events per sample
plotAberrantPerSample(ods, padj=0.05)
@

\subsection{Volcano plots}

To view the distribution of P-values on a sample level, volcano plots can 
be displayed. Most of the plots make use of the \CRANpkg{plotly} 
framework to create interactive plots. For the vignette, we will always use 
the basic R functionality from \CRANpkg{graphics}. 

<<volcano, fig.height=5>>=
# MUC1344 is a diagnosed sample from Kremer et al.
plotVolcano(ods, "MUC1344", basePlot=TRUE)
@


\subsection{Gene plots}

Additionally, we include two plots at the gene level. 
\Rfunction{plotExpressionRank} plots the counts in ascending order. 
By default, the controlled counts are plotted. To plot raw counts, the argument 
\Robject{normalized} can be set to FALSE. 

When using the \CRANpkg{plotly} framework for plotting, all computed values 
are displayed for each data point. The user can access this information 
by hovering over each data point with the mouse.

<<visualization2, fig.height=5>>=
# expression rank of an outlier gene
plotExpressionRank(ods, "TIMMDC1", basePlot=TRUE)
@

The quantile-quantile plot can be used to see whether the fit converged well.
In presence of an outlier, it can happen that most of the points end up below 
the confidence band. This is fine and indicates that we have conservative 
P-values for the other points. Here is an example with two outliers:

<<visualization3, fig.height=5>>=
## QQ-plot for a given gene
plotQQ(ods, "TIMMDC1", legendPos="topleft")
@

\section*{Session info}

Here is the output of \Rfunction{sessionInfo()} on the system on which 
this document was compiled:

<<sessionInfo, echo=FALSE>>=
sessionInfo()
@

\end{document}
